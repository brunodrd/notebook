S√©quence 2 - Repr√©senter du texte
================================

## L'objectif
Il s'agit d'**associer un caract√®re √† un num√©ro unique**: c'est ce que l'on appelle **encoder**. Pour √™tre efficace un encodage doit repr√©senter le plus de caract√®res possible et √™tre compact.

## L'ASCII
√Ä l'origine plusieurs encodages incompatibles entre eux coexistaient jusqu'√† ce qu'une norme s'impose dans les ann√©es 60: l'**A**merican **S**tandard **C**ode for **I**nformation **I**nterchange (ASCII).  
Un octet est utilis√© pour coder un caract√®re. En r√©alit√©, seuls 7 bits sont utilis√©s: on peut donc coder $2^7=128$ caract√®res avec cette norme. Le dernier bit √©tait utilis√© √† des fins de contr√¥le lors des transmissions.  
Il faut noter que seuls les caract√®res *anglo-saxons* sont pr√©sents. Les caract√®res accentu√©s ne sont pas repr√©sentables.

## √âvolution: la norme ISO 8859
Afin d'int√©grer plus de caract√®res (*notamment les caract√®res accentu√©s*), une premi√®re √©volution a eu lieu et a √©t√© caract√©ris√©e par la norme ISO 8859.  
Il s'agit d'une extension de l'ASCII: on utilise le 8√®me bit (utilis√© jusque l√† pour le contr√¥le de parit√©) pour coder des caract√®res. On a ainsi $2^8=256$ possibilit√©s !
Une table de correspondance code hexad√©cimal ou d√©cimal $\longleftrightarrow$ ASCII et ASCII √©tendu peut √™tre trouv√©e √† cette [adresse](http://www.asciitable.com/)

## Norme ISO 10646 - Standard Unicode
Bien qu'int√©ressante l'√©volution vers la norme ISO 8859 ne r√®gle pas tous les probl√®mes et notamment l'encodage des caract√®res des langues autres qu'europ√©ennes (*asiatiques entre autres*).  
Pour tenir compte de tous les caract√®res utilis√©s, l'ISO proposa une nouvelle norme dans laquelle un caract√®re est vu comme une *entit√©* poss√©dant:  

*  un nom;  
*  un num√©ro, appel√© encore **point de code** et not√© U+xxxx o√π xxxx est un nombre hexad√©cimal.  

[Voir la page wikipedia](https://fr.wikipedia.org/wiki/Table_des_caract%C3%A8res_Unicode_\(0000-0FFF\))  

Un consortium priv√© √† but non lucratif, **Unicode**, proposa alors plusieurs techniques pour encoder ces points de code. La plus utilis√©e est manifestement l'encodage **UTF-8** (Universal Transformation Format); le *8* signifie qu'il faut au minimum 8 bits pour repr√©senter le caract√®re associ√© √† un point de code.  
Les encodages UTF-16 (complexe) et UTF-32 (peu √©conome) ne seront pas abord√©s ici.

## Principe de l'encodage UTF-8
Cet encodage permet de coder un caract√®re sur 1, 2, 3 ou 4 octets. Si le point de code est inf√©rieur ou √©gal √† 127 (`7F` en hexad√©cimal), le caract√®re est cod√© sous la forme `0xxx xxxx` **comme en ASCII**.  
Sinon, on utilise la forme binaire du point de code et on d√©termine ainsi le nombre de bits n√©cessaire au codage du caract√®re.

| Point de code    	| Octets (binaire)                        	| Nb de bits <br>utiles 	|
|------------------	|-----------------------------------------	|-----------------------	|
| U+0000-U+007F    	| 0xxx xxxx                               	| 7                     	|
| U+0080-U+07FF    	| 110x xxxx 10xx xxxx                     	| 11                    	|
| U+0800-U+FFFF    	| 1110 xxxx 10xx xxxx 10xx xxxx           	| 16                    	|
| U+10000-U+10FFFF 	| 1111 0xxx 10xx xxxx 10xx xxxx 10xx xxxx 	| 21                    	|

L'octet de poids fort est compos√© d'une s√©quence de 1 termin√© par un 0. Le nombre de 1 pr√©sent dans cette s√©quence indique le nombre d'octet utilis√© pour coder le caract√®re.  

**Exemple**  
Soit √† coder le symbole de l'ensemble vide $\varnothing$ qui a pour point de code 8709 ou U+2205.  
Le point de code exprim√© en binaire est: `10 0010 0000 0101`. Il faut 14 bits pour coder ce nombre. D'apr√®s le tableau ci-dessus, on va utiliser un codage sur 3 octets:  

$$
\mathbf{1110}\ 0010\ \mathbf{10}00\ 1000\ \mathbf{10}00\ 0101
$$

!!! warning "Prolongement hors programme: Unicode et Python"
    Les chaines de caract√®res en python utilisent l'encodage UTF-8. Par ailleurs, on peut saisir directement une chaine √† partir de ses points de code (qu'on 
    peut trouver sur le site [https://unicode-table.com/fr/](https://unicode-table.com/fr/) par exemple), en proc√©dant ainsi:  
    
    * '\u' suivi du point de code √©crit avec quatre chiffres hexad√©cimaux, si sa valeur est comprise entre `0000` et `FFFF`;
    * '\U' suivi du point de code √©crit avec huit chiffres hexad√©cimaux, si sa valeur est sup√©rieure √† `FFFF`.
    
    Voir les exemples ci-apr√®s.

**Exemples d'utilisation en python**


```python
ch1 = '\u0078\u2A7E\u0030'
print(ch1)
```

    x‚©æ0



```python
ch2 = '\U0001F914'
print(ch2)
```

    ü§î


Il est possible en python de conna√Ætre le r√©sultat de l'encodage (en hexad√©cimal), en utilisant la *m√©thode* de cha√Æne `encode` (le terme *m√©thode* sera pr√©cis√© en terminale).


```python
tableau_octets = ch1.encode('utf8') # encode prend en param√®tre le type d'encodage
for valeur in tableau_octets:
    print(hex(valeur))
```

    0x78
    0xe2
    0xa9
    0xbe
    0x30


!!! info "Remarque"
    Le tableau d'octets et la chaine de caract√®res n'ont pas m√™me la longueur. Cela montre qu'en UTF-8, un caract√®re peut √™tre cod√© sur plusieurs octets. Ici, le caract√®re *sup√©rieur ou √©gal* est cod√© sur trois octets.  

On peut √©galement faire le conversion inverse (d'une chaine d'octets vers une chaine caract√®res) avec la *m√©thode* `decode`.


```python
a = b'\x78\xe2\xa9\xbe\x30' # b' ' signifie qu'on traite une cha√Æne d'octets (bytes)
a.decode('utf8')
```




    'x‚©æ0'



---
**R√©f√©rences**  

Sp√©cialit√© NSI 1re - Balabonski et al. - ellipses  
[lien vers la description](https://www.editions-ellipses.fr/accueil/118-10382-specialite-numerique-et-sciences-informatiques-30-lecons-avec-exercices-corriges-premiere-nouveaux-programmes-9782340033641.html#/1-format_disponible-broche)
